<Process Concept>

1. Program / Process
프로그램은 프로세스가 아니다.
프로그램 : 디스크에 저장된 명령 목록(실행 파일)을 포함하는 파일과 같은 수동 개체(passive entity) -> 메모리에 올라가기 전
프로세스 : 실행할 다음 명령 및 관련 리소스 집합을 지정하는 프로그램 카운터를 가지는 활성 개체(active entity) -> 메모리에 올라간 후

프로그램은 실행 파일이 메모리에 로드될 때, 프로세스가 됨.
실행 파일을 메모리에 로드하려면, 실행 파일을 실행하면 됨.
프로세스의 범위 : 메모리 구조 + Register set(중앙 처리 장치(CPU) 내에 위치한 작은 고속 기억 장치로서, CPU가 특정 프로그램을 실행하기 위한 데이터를 일시적으로 저장하는데 사용됨.)

Register set : CPU가 특정 프로그램을 실행 중 -> 프로세스가 Running 상태임. -> CPU 내부 레지스터들은 프로그램 실행을 위한 데이터들로 채워짐. 그래서 레지스터의 상태도 프로세스의 일부로 포함시켜야 함.

2. 프로세스의 메모리 구조

-(1) Text Section(Code Segment)
프로그램의 실행 코드가 저장되는 영역임.
CPU는 이 섹션에서 명령어를 읽어와 실행함.
읽기 전용으로 설정되어 있어 프로그램 코드가 변경되지 않음.

-(2) Data Section
초기화된 전역 및 정적 변수가 저장되는 영역임.
프로그램 시작 시 미리 할당되고 초기화된 데이터들이 저장됨.
읽기 / 쓰기 권한이 있음.

-(3) BSS Section
초기화되지 않은 전역 및 정적 변수가 저장되는 영역임.
프로그램 시작 시 메모리는 할당되지만, 0으로 초기화 되지 않은 변수들이 여기에 저장됨.
읽기 / 쓰기 권한이 있음.

- (4) Heap Section
동적으로 할당된 메모리가 저장되는 영역임.
프로그램 실행 중에 동적으로 메모리를 할당하고 해체할 수 있음.
힙은 메모리가 필요에 따라 동적으로 확장되거나 축소됨.
읽기 / 쓰기 권한이 있음.

-(5) Stack Section
함수 호출 및 지역 변수가 저장되는 영역임.
함수 호출 시 임시 데이터 저장(ex : function parameters, return address, local variables)
프로그램이 함수를 호출할 때마다 스택 프레임이 생성되고 함수의 지역 변수 및 복귀 주소가 여기에 저장됨
후입선출(LIFO) 구조를 가지며, 스택 포인터(SP)가 스택의 최상단을 가리킴.
제한된 크기를 가지며, 스택이 가득 차면 스택 오버 플로우가 발생할 수 있음.

-(6) Memory Mapping
동적 라이브러리, 공유 라이브러리 등이 메모리에 매핑되는 영역임.
라이브러리나 다른 실행 파일의 코드 및 데이터를 고유하기 위해 사용됨.

텍스트 및 데이터 섹션의 크기는 프로그램 실행 시간동안 변경되지 않기 때문에 고정되어 있음.
스택 및 힙 섹션은 프로그램 실행 중에 동적으로 축소 및 확장될 수 있음.

함수가 호출될 때마다 activation record가 스택에 push됨.
함수에서 제어가 반환되면, activation record가 스택에서 빠짐.
activation record에는 function parameters, return addresses, local variable이 포함.

힙은 메모리가 동적으로 할당됨에 따라 커짐.
메모리가 시스템에 반환되면 축소됨.

OS는 스택과 힘 섹션이 커지더라도 겹치지 않도록 해야함.

High Memory (높은 메모리)
사용자 공간 -> 응용 프로그램을 위한 공간
High Memory는 주소 공간의 상단 또는 높은 주소 값을 나타냄.
일반적으로 시스템이나 프로세스에서 사용 가능한 주소 공간의 상단 부분을 의미함.
(ex : 32bits system에서 주소 0xFFFFFFFF나 그 근처부터 높은 메모리로 간주 될 수 있음.)

Low Memory (낮은 메모리)
커널 메모리 -> OS를 위한 공간
Low memory는 주소 공간의 하단 또는 낮은 주소 값을 나타냄.
일반적으로 주소 0부터 시작하여 상단으로 증가하는 방식으로 사용 가능한 주소 공간의 하단 부분을 의미함.
낮은 주소 부분은 일반적으로 프로그램 코드, 데이터 세그먼트, 힙 등의 메모리 영역이 할당됨.
주로 프로그램의 실행 코드와 데이터가 낮은 주소에 위치하게 됨.

스택 프레임이란?
함수 호출 시에 생성되어 함수의 실행 내용(ex : 매개변수, 지역변수 등)을 관리하는 데 사용되는 메모리 블록임.
각 함수 호출은 해당 함수의 스택 프레임을 가지며, 스택에는 여러 함수 호출에 대한 스택 프레임들이 쌓임.
스택 프레임은 함수의 지역 변수, 매개 변수, 반환 주소 및 실행 도중에 필요한 기타 정보를 저장함. 

(ex)
#include <stdio.h>
#include <stdlib.h> // 프로그램이 표준 입출력 및 메모리 관리 기능을 사용하도록 하는 헤더 파일

int x; // BSS section -> 초기화 되지 않은 전역 변수가 저장됨.
int y = 15; // Data section -> 초기화 된 전역 변수가 저장됨.

int main(int argc, char *argv[]) // 스택 섹션에 저장됨. > main 함수의 매개 변수 argc, argv는 함수 호출 시에 스택 프레임에 저장됨.
{
	int *values;
	int i; // 스택 섹션에 저장됨

	values = (int *)malloc(sizeof(int)*5); // 힙 섹션에 저장됨.

	for(i=0; i<5; i++)
		values[i] = i;
	return 0;
}

3. Process State
프로세스의 상태(Process State)는 현재 실행 중인 프로세스가 어떤 상태에 있는지를 나타내는 것임.
모든 코어에서는 한 번에 하나의 프로세스만 실행할 수 있음. 그러나 많은 프로세스가 준비되어 대기 중일 수도 있음.
프로세스가 실행되면 state가 변경됨.
프로세스의 state는 해당 프로세스의 현재 activity에 의해 정의됨.
OS에 따라 state의 이름과 state의 개수가 다를 수 있음.

New(생성)
프로세스가 생성되고, 초기화 되어 운영 체제에 등록되기 전의 상태
프로세스가 생성되는 중

Ready(준비)
프로세스가 실행을 기다리는 상태임.
CPU를 할당받을 준비가 되어있지만, 아직 실행되지 않은 상태임.
프로세스(실행 중인 프로그램)가 프로세서(연산 장치 -> CPU)에 할당되기를 기다리는 중

Running(실행)
현재 CPU에서 실행 중인 상태임.
CPU를 사용하여 명령어를 실행하고 작업을 수행하고 있음.

Waiting or Blocked(대기 또는 차단)
프로세스가 어떤 이벤트가 발생하기를 기다리는 중(ex : I/O 완료 또는 signal 수신)
외부 자원에 접근할 수 없는 상태임.
대기 중인 이벤트가 발생하면, 프로세스는 Ready 상태로 전이될 수 있음.

Terminated(종료)
프로세스의 실행이 완료되었거나 종료되었을 때의 상태
프로세스가 실행을 완료하고 종료됨.
운영 체제에 의해 메모리에서 해제되고 관련 리소스가 해제됨.

4. Process Control Block(PCB)
OS에서 특정 프로세스의 정보를 담고있는 블록임.
Task Control Block이라고 하기도 함.

PCB(Process Control Block)
일부 accounting data와 함께 프로세스를 시작하거나 다시 시작하는 데, 필요한 모든 데이터를 저장함.
운영 체제가 각 프로세스를 관리하기 위해 유지하는 중요한 자료 구조임.
각 프로세스에 대한 정보를 저장하고 있으며, 프로세스의 상태, 레지스터 값, 스케줄링 정보, 메모리 관리 정보 등 다양한 정보를 담고 있음.

PCB의 구성 요소

Process State : 프로세스의 현재 상태

Process number : PID, 프로세스의 고유한 식별자

Program Counter(중요) : CPU 내부에 있는 레지스터 중 하나로서, 다음에 실행될 명령어의 주소를 가짐(다음에 실행할 명령어의 주소를 가리키는 레지스터 값임.) 

CPU 레지스터 : OS에 따라 사용처가 다르지만, 보통 인터럽트 이후에 프로세스가 기존에 하던 일을 올바르게 계속될 수 있도록 하는 stack pointer로 사용됨.

메모리 관리 정보 : base,limit 레지스터, 페이지 테이블, 세그먼트 테이블의 값(프로세스의 주소 공간과 메모리 할당에 관한 정보를 포함함. -> 프로세스의 코드, 데이터, 스택 등이 어디에 위치하는 지를 나타냄.)

I/O status 정보 : 프로세스에 할당된 I/O 장치 목록, 열린 파일 목록 등
  
Accounting 정보 : 사용된 CPU 및 실시간 시간, 시간 제한, task 또는 프로세스의 개수 등

CPU 스케줄링 정보(중요) : 프로세스의 우선순위, 스케줄링 큐 포인터 등 스케줄링 파라미터 정보(운영체제가 프로세스를 스케줄링할 때 필요한 정보를 담고 있음.)

(PID란?
Process ID로, 프로세스를 식별하기 위한 고유한 식별자임.
각 프로세스는 운영 체제에서 할당받은 고유한 PID를 가지며, 이를 통해 운영체제는 각 프로세스를 식별하고 관리할 수 있음.

PID의 특징
- 고유성 
각 프로세스는 시스템 내에서 유일한 PID를 부여받음. 즉, 동일한 PID를 가진 2개의 프로세스는 동시에 존재할 수 없다.
- 숫자 값
PID는 정수로 표현되며, 일반적으로 0부터 시작하여 시스템에서 실행 중인 각 프로세스에 대해 1씩 증가하는 값을 가짐.
- 부모-자식 관계
일반적으로 자식 프로세스는 fork() 시스템 호출을 통해 생성되고, 이때 자식 프로세스는 부모 프로세스의 메모리 공간을 복사함. 
그러나 PID는 부모 프로세스와 자식 프로세스 간에 다르게 설정됨.
- 프로세스 식별
PID는 프로세스를 고유하게 식별하는 데 사용되며, 운영체제에서 프로세스의 상태를 추적하고 관리하는 역할을 함.)

5. Process Scheduling
운영체제가 여러 프로세스들 중에서 어떤 프로세스를 실행 시킬지를 결정하는 작업임.
여러 프로세스가 동시에 실행되는 다중 프로그래밍 환경에서 CPU의 할당 및 사용을 최적화하여 시스템의 성능을 향상시키는 것이 목적임.
어떤 프로세스를 어떤 코어에 할당할 것인가 결정하는 것.

Multi-programming
CPU 활용도를 최대화하기 위해 사용함.
하나의 프로세서(연산 장치)가 하나의 프로세스(메모리에 들어가는 프로그램)를 수행하는 동안 다른 프로세스에 접근할 수 있도록 하는 방법.

Multitasking
프로세스(메모리에 들어간 켜진 프로그램) 사이에 CPU 코어를 자주 전환하여 사용자가 실행 중인 각 프로그램과 상호작용할 수 있도록 하는 것.

Process Scheduler
코어에서 사용 가능한 프로세스를 선택함.
각 코어는 한 번에 하나의 프로세스를 실행할 수 있음.
프로세스 수명동안 ready queue와 다양한 wait queue들 사이를 이동함.
CPU 스케줄러는 ready queue에 있는 프로세스 중에서 프로세스를 하나 선택하고, 그 프로세스에 코어를 할당함.

Scheduling Queues
Ready queue : CPU 할당을 대기 중인 프로세스 중 실행될 준비가 된 프로세스를 위한 큐

Wait queue : CPU 코어에서 실행되는 프로세스가 특정 이벤트가 발생할 때까지 기다릴 때, 들어가는 큐.(ex : I/O 요청 등)

Job queue : 메모리 할당을 대기 중인 프로세스를 위한 큐.

Device queue : I/O 장치 할당을 대기중인 프로세스를 위한 큐.

각 queue header에는 목록의 첫 번째 PCB에 대한 포인터가 포함됨.
각 PCB에는 준비 대기열의 다음 PCB를 가리키는 포인터 필드가 포함됨.
(포인터 필드(Pointer Field)
일반적으로 구조체나 클래스 내부에 선언된 포인터 변수를 가리키는 용어임.
해당 구조체나 클래스의 인스턴스 내에서 다른 데이터나 구조체를 가리키는 역할을 함.
데이터 구조에서 객체나 구조체 간의 관계를 나타내거나 연결 리스트와 같은 자료구조에서 다음 노드를 가리키는 데 사용됨.)

Process Scheduling
-(1) 새 프로세스는 처음에 ready queue에 들어감. 실행을 위해 선택되거나 디스패치될 때까지 대기함.
-(2) 프로세스에 CPU 코어가 할당되고 실행됨.
-(3) 프로세스에 CPU 코어가 할당되고 실행되면 아래 이벤트 중 하나가 발생할 수 있다.
(이벤트
프로세스는 I/O 요청을 한 다음, I/O wait queue에 배치될 수 있음.
프로세스는 새 자식 프로세스를 만든 다음, 자식의 종료를 기다리는 동안 wait queue 에 배치될 수 있음.
프로세스는 인터럽트 또는 제한시간 만료로 인해 코어에서 강제로 제거 되고 wait queue에 다시 배치될 수 있음.)
(인터럽트 : 컴퓨터 시스템에서 발생하는 이벤트나 조건에 의해 현재 실행 중인 프로그램의 정상적인 흐름을 일시적으로 변경하고, 미리 정의된 특정 코드(인터럽트 핸들러)로 제어를 넘기는 기술임.)
-(4) 프로세스는 종료될 때까지 이 사이클을 반복함.
-(5) 프로세스가 종료될 때, 모든 queue에서 제거되고, PCB 및 리소스 할당이 해제됨.

I/O-bound process
계산보다 I/O를 수행하는 데 더 많은 시간을 소비함.
많고 짧은 CPU bursts를 가짐. -> I/O 요청을 기다리기 전에 몇 m/s동안만 CPU에서 실행됨.

CPU-bound process
계산에 더 많은 시간을 할애함.
매우 긴 CPU bursts가 거의 없음. -> 더 긴 기간 동안 CPU 코어를 필요로 함.
스케줄러는 장기간 동안 코어를 한 프로세스에 부여하려고 하지 않을 것이므로, 이에 대한 핸들링이 필요하다.
(스케줄러는 CPU-bound process보다 I/O-bound process에 더 높은 우선 순위를 부여하는 경향이 있음.)

Swapping
메모리나 CPU에 대해 경합하는 프로세스의 수가 증가할수록 오버헤드가 늘어나 성능이 하락할 수 있음.
이 중 몇몇 프로세스를 제거하여(swapped out) multi-programming(여러가지 프로세스를 한 번에 실행하는 것)의 정도를 줄이는 것
나중에 프로세스를 메모리에 다시 도입할 수 있으며, 중단된 위치에서 계속 실행할 수 있음.
(오버헤드(Overhead) : 시스템이나 프로세스에 부가적으로 발생하는 부담이나 비용
오버헤드는 시스템의 성능을 저하시킬 수 있으며, 따라서 최소화하고 효율적으로 관리하는 것이 중요함.)

Context Switch
인터럽트가 발생하여 코어를 다른 프로세스로 전환할 때, 현재 프로세스의 상태를 저장하고 다른 프로세스의 상태 복원을 수행하는 것임.
Context Switch 발생 시, PCB를 통해 (1) 이전 프로세스의 Context를 저장하고, (2) 실행이 예약된 새 프로세스의 저장된 Context를 로드함.
Context Switch에 걸리는 시간은 전환하는 동안 시스템이 유용한 다른 작업을 수행하지 않기 때문에 순수 오버헤드임.(하드웨어에 크게 의존함.)
OS가 복잡할수록 Context Switch 중에 수행해야 하는 작업의 양이 늘어남.

6. Operations on Processes
대부분의 시스템에서 프로세스는 동시에 실행될 수 있으며 동적으로 생성 및 삭제될 수 있음.
OS는 프로세스 생성 및 종료를 위한 메커니즘을 제공해야 함. 

Process Creation
실행 과정에서 프로세스는 새 프로세스들(자식들)을 생성할 수 있음.
생성 프로세스 == 부모 프로세스 
부모 프로세스로부터 생성된 새 프로세스 == 자식 프로세스
(ex : 프로세스 트리)

OS는 PID에 따라 프로세스를 부모 프로세스인지 자식 프로세스인지 구별함.

pid 
시스템의 각 프로세스마다 고유하게 주어지는 값 
각 프로세스에 접근하기 위한 인덱스의 역할

부모 프로세스가 자식 프로세스를 만들 때, 해당 자식 프로세스는 작업을 수행하기 위한 특정 리소스(CPU시간, 메모리, 파일, I/O장치)가 필요함.
자식 프로세스는 운영 체제에서 직접 리소스를 얻을 수 있지만, 보통은 사용 가능한 리소스가 부모 프로세스의 리소스로 제한됨.
프로세스가 너무 많은 자식 프로세스를 만들어서 시스템에 과부하가 걸리는 것을 방지하기 위함.
(리소스(Resource)
컴퓨터 시스템에서 프로그램이나 프로세스가 동작하는데 필요한 자원을 말함.
시스템 리소스 : CPU, 메모리, 디스크 공간, 네트워크 리소스
프로세스 관련 리소스 : 프로세서 시간, 메모리 공간, 파일 디스크립터, 프로세스 간 통신 메커니즘
SW 리소스 : 라이브러리 및 모듈, 시스템 호출 및 API)
부모 프로세스에서 자식 프로세스를 생성할 때 발생하는 부하와 리소스 소모를 고려하여 시스템은 허용 가능한 수의 프로세스를 정의함. 
부모 프로세스가 자식 프로세스를 생성할 때마다 새로운 프로세스가 독립적인 메모리 공간을 가지기 때문에, 무한정으로 프로세스를 생성할 수 없음.

fork 시스템 콜을 사용하여 프로세스가 새 프로세스를 생성할 때
부모는 자식과 동시에 계속 실행됨.
부모는 자식의 일부 또는 전체가 종료될 때까지 기다림.(wait 시스템 콜 사용)

새 프로세스에는 2가지 주소 공간 가능성이 있음.
자식 프로세스는 부모 프로세스의 복제본(부모와 동일한 프로그램 및 데이터를 가짐.)
자식 프로세스에 새 프로그램이 로드되어  있음.(exec 시스템 콜 사용)

fork() 시스템 콜에 의해 새 프로세스가 생성됨.
새 프로세스는 원래 프로세스 복사본임.
자식의 pid == 0임(이 pid를 통해 부모와 자식 프로세스를 다르게 행동하게 할 수 있음.)
두 프로세스(부모 및 자식) 모두 fork() 이후의 명령어에서 계속 실행됨.

자식 프로세스는 exec() 시스템 콜을 사용하여, 프로세스의 메모리 공간을 다른 프로세스의 내용으로 교체하여 실행시작함.

부모 프로세스는 wait() 시스템 콜을 사용하여, 자식 프로세스가 종료할 때까지 기다림.
wait() 시스템 콜은 종료된 자식의 pid를 반환함.
wait() 시스템 콜을 사용하는 이유는 자식 중 어떤 자식이 종료되었는지 식별하기 위함.

Process Termination
프로세스는 최종 명령문 실행을 완료하고 운영 체제에 exit() 시스템 콜을 사용하여 삭제하도록 요청하면 종료됨.
할당된 메모리, 열린 파일, I/O 버퍼를 포함한 프로세스의 모든 리소스는 운영 체제에서 할당을 취소하고 회수됨.

좀비 프로세스(zombie process)
원인 : process table에서 자식 프로세스의 entry는 부모 프로세스가 wait()을 호출할 때까지 남아 있음.
결과 : 종료가 되었지만, 부모 프로세스가 아직 wait() 호출을 하지 않은 프로세스를 좀비 프로세스라고 함.
좀비 프로세스 : 자식이 죽고 자식에게 나눠줬던 부모의 리소스를 거둬들이지 않아서(wait) 생성됨(자식이 죽지도 못함.)
OS는 한정된 숫자의 pid를 가지고 있음.
좀비 프로세스가 pid의 한계까지 차지하면, pid를 할당해야 할 프로세스에 더 이상 pid를 할당할 수 없게 되어 다른 프로세스 실행을 방해하게 됨.

고아 프로세스(orphan process)
부모가 wait()를 호출하지 않고 먼저 종료되면, 자식 프로세스는 orphan process가 됨.
부모가 먼저 종료되면서(죽으면서) 리소스가 낭비됨.
리소스가 낭비되어 성능 저하의 원인이 됨.
OS는 보통 부모보다 더 상위의 프로세스를 고아 프로세스에 새 부모로 할당함.
init 프로세스 : UNIX 시스템에서 프로세스 계층의 루트 역할
init 프로세스는 주기적으로 wait() 시스템 콜을 호출하여 고아 프로세스를 종료하고 리소스를 반환함.

7. Interprocess Communication
independent process : 시스템에서 실행 중인 다른 프로세스와 데이터를 공유하지 않는 프로세스
cooperationg process : 다른 프로세스와 데이터를 공유하는 모든 프로세스
시스템에서 실행 중인 다른 프로세스에 영향을 미치거나 영향을 받을 수 있음.

프로세스끼리 왜 Communication을 시키는가?(프로세스 협력을 허용하는 환경을 제공하는 이유)
-(1) 정보 공유 : 여러 애플리케이션이 동일한 정보가 필요한 경우를 위해 정보에 동시 접근을 허용함.(ex : 복사, 붙여넣기)
-(2) 계산 속도 : 각 task를 subtasks로 나누어 병렬 실행하여 속도를 향상. 멀티프로세서 환경에서만 가능.
-(3) 모듈화 : 시스템 기능을 별도의 프로세스 또는 스레드로 분할하여 모듈 방식으로 시스템을 구성할 수 있음.
각 모듈을 독립적으로 관리하는 것이 가능함.
프로세스에 실시간으로 모듈을 붙여 작동시킬 수 있음.
 
IPC(interprocess communication)
프로세스 간에 데이터를 교환하고 상호 작용하기 위한 메커니즘을 의미함.
다수의 프로세스가 동작하는 환경에서 각 프로세스가 효과적으로 통신하고 협력할 수 있도록 하는 기술
Cooperating process에는 서로 데이터를 주고 받을 수 있는(데이터 교환) IPC 메커니즘이 필요

IPC의 목적
-(1) 데이터 전송 : 프로세스 간에 데이터를 주고 받아 서로 정보를 공유함.
-(2) 프로세스 제어 : 한 프로세스가 다른 프로세스의 동작을 제어하거나, 상태를 확인하고 조작함.
-(3) 동기화 : 다수의 프로세스가 동시에 실행될 때, 실행 순서를 조절하고 상호 배제를 통해 안정성을 유지함.
-(4) 프로세스 간 신호 전달 : 프로세스에게 특정 이벤트가 발생했음을 알리기 위해 사용됨.

IPC 기본 모델
-(1) shared memory : 두 프로세스가 동일한 메모리 영역을 공유하여 데이터를 교환하는 메커니즘
-(2) message passing : 프로세스 간에 데이터나 메시지를 전송하여 통신하는 메커니즘 -> Message Queue : 프로세스 간에 메시지를 전송하고 수신하는 큐 기반의 통신 방식임.
-(3) pipe : 두 프로세스 간의 단방향 통신을 제공하는 메커니즘
-(4) semaphore : 프로세스 간의 동기화와 상호배제를 위해 사용되는 카운팅 세마포어나 이진 세마포어 등이 있음.
-(5) socket : 네트워크 환경에서 프로세스 간 통신을 위한 매우 일반적인 메커니즘으로, 로컬 또는 원격 통신에 사용됨.

Producer-Consumer Problem
두 프로세스가 동시에 동작할 때 일어나는 이슈
일반적으로 정보가 생산되는 속도가 소비하는 속도보다 빠르기 때문에 동기화 문제가 발생함.
멀티스레딩 환경에서 발생하는 동기화 문제 중 하나로 고유된 버퍼나 큐에 여러 생산자 스레드가 이 데이터를 소비하는 상황을 다룬다. 
(ex : 서버 = Producer, 클라이언트 = Consumer인데, 웹 서버는 리소스를 요청하는 클라이언트 웹 브라우저가 읽는 웹 콘텐츠를 생성하고 제공함.
이때, 클라이언트가 최신 업데이트 된 콘텐츠를 소비하도록 할 필요가 있음.)

Cooperating process 안에서
Producer(생산자) : 정보를 생산하는 프로세스
Consumer(소비자) : 정보를 소비하는 프로세스

Producer-Consumer Problem에 대한 해결책 - Shared memory(메모리 자체를 공유하는 것)
메모리에 생산된 데이터를 담아두는 버퍼를 만듦. 
유한 버퍼(Bounded buffer) : Consumer는 버퍼가 비어 있으면 기다려야 하고, Producer는 버퍼가 가득 차면 기다려야 함.
무한 버퍼(Unbounded buffer) : 버퍼의 시작과 끝을 이어 붙여 크기가 무한한 버퍼
Cooperating Process가 공유하는 메모리 영역이 설정됨.
그런 다음 프로세스는 공유 영역에서 데이터를 읽고 쓰는 방식으로 정보를 교환함.
충돌을 막기 위해 메모리에 동시 접근하는 것을 따로 방지해야 함.

Massage passing
Cooperating process 간에 교환되는 메시지를 통해 통신
-(1) 프로세스들 사이에 통신 링크를 설정
-(2) 보내기/받기를 통해 메시지 교환
메시지 패싱은 Context Switch가 발생하기 때문에 속도가 느림.
커널이 기본적인 기능을 제공
공유 메모리 방식에 비해 개발자 입장에서 구현이 쉽다.
(커널이란?
운영체제의 핵심 부분으로, 하드웨어와 소프트웨어 간의 인터페이스 역할을 하며 시스템 자원을 관리하고 프로세스를 제어하는 핵심적인 컴퓨터 프로그램임. 
운영 체제 커널은 컴퓨터의 기본 동작을 제어하고, 응용 프로그램이 하드웨어 리소스에 접근할 수 있도록 지원함.)

Message passing의 링크 설정
-(1) Direct communication
프로세스는 서로의 이름을 명시적으로 지정해야 함.
쌍 사이에는 하나의 양방향 링크가 있음.
이름을 미리 알기가 어렵다.
-(2) Indirect communication
Mail box(port)를 통해 링크가 생성됨.
링크가 많은 프로세스와 연관될 수 있음.
프로세스는 여러 통신 링크를 공유할 수 있음.
링크는 단방향일수도 양방향일 수도 있음.

Message passig example
Mailbox를 프로세스1이 프로세스2, 프로세스3에게 메시지를 보낼 때 사용할 경우
Process1 -> Mailbox1 -> Process2
                             -> Process3
해결책
-(1) 링크가 최대 2개의 프로세스만 연결되도록 함.
-(2) Broadcasting
-(3) 하나의 프로세스만 메시지 수신 허용
-(4) 송신 프로세스가 수신자를 선택하도록 허용

Mailbox Synchronization
Message passing의 동기화를 위해 blocking 방식과 non-blocking 방식이 사용됨.
blocking 방식 : Synchronous 동기식
non-blocking 방식 : Asynchronous 비동기식

Blocking send : 수신자가 메시지를 받을 때까지 송신자는 block됨.
Blocking receive : 메시지를 수신할 때까지 수신자는 block됨.

Non-blocking send : 송신자가 메시지를 보내고 작업을 계속함.
Non-blocking receive : 수신자가 유효한 메시지나 NULL 메시지를 받음.

Pipe
두 프로세스가 통신할 수 있도록 하는 연결관 역할을 함.
초기 UNIX 시스템에서 최초의 IPC 메커니즘 중 하나임.
단방향 통신만 가능함. -> 파이프는 쓰기용과 읽기용으로 이렇게 2개를 만들어주어야 함.
양방향 통신이 필요한 경우, 각 파이프가 다른 방향으로 데이터를 보내는 2개의 파이프를 사용해야 함.
Ordinary pipes : 부모자식 관계에만 사용 가능함.
named pipes : 부모-자식 관계뿐만 아니라 부모-자식 관계가 아닌 프로세스끼리도 통신 가능하게 함.

Communication in Client - Server Systems
클라이언트와 서버의 통신을 위해 일반적으로 2개의 방법을 사용함.
-(1) Sockets
소켓은 서버와 클라이언트가 통신하는 방식임.
IP주소와 포트 정보가 있으면 클라이언트는 네트워크를 통해 서버 프로세스에 접근할 수 있음.
-(2) RPC(Remote Procedure Calls)
별도의 원격 제어를 위한 코딩 없이 별도의 컴퓨터에 있는 다른 프로세스에서 function(procedure)를 호출할 수 있는 방식임.
프로세스는 원래 같은 컴퓨터 내의 function(procedure)만 호출하여 실행 가능함. 그러나
RPC는 별도의 컴퓨터의 프로세스의  function(procedure)를 실행할 수 있게 해줌.
클라이언트 - 서버 간의 커뮤니케이션에 필요한 상세 정보를 최대한 감출 수 있음.
클라이언트는 일반 메소드를 호출하는 것처럼 간단하게 원격 컴퓨터의 function(procedure)를 호출할 수 있음.